// RUN: rm -f %t.ll ; \
// RUN: %thorin -d autodiff %s --output-ll %t.ll --output-thorin -

.import core;
.import autodiff;
.import mem;

.let i32 = .Idx 4294967296;

.con f [[mem : %mem.M, a: %mem.Ptr («100:.Nat; i32», 0)], ret: .Cn [mem : %mem.M, i32]] = {
    .let lea = %mem.lea (100:.Nat, <100:.Nat; i32>, 0) (a, 1:(.Idx 100));
    .let (load_mem, load_val) = %mem.load (i32, 0) (mem, lea);
    .let scaled = %core.wrap.mul 4294967296 0 (100:i32, load_val);
    ret (load_mem, scaled)
};

.con .extern main [mem : %mem.M, argc : i32, argv : %mem.Ptr (%mem.Ptr (.Idx 256, 0:.Nat), 0:.Nat), return : .Cn [%mem.M, i32]] = {

    .con ret_cont [[mem : %mem.M, a: i32], pb:.Cn[[%mem.M, i32],.Cn[[%mem.M, %mem.Ptr («100:.Nat; i32», 0)]]]] = {
        .con pb_ret_cont [mem : %mem.M, pba: %mem.Ptr («100:.Nat; i32», 0)] = {
            .let lea = %mem.lea (100:.Nat, <100:.Nat; i32>, 0) (pba, 1:(.Idx 100));
            .let (load_mem, load_val) = %mem.load (i32, 0) (mem, lea);
            return (load_mem, load_val)
        };
        // pb((mem, a), pb_ret_cont)
        pb((mem, (1:i32)), pb_ret_cont)
    };

    .let (alloc_mem, alloc_val) = %mem.alloc («100:.Nat; i32», 0) mem;

    .let lea = %mem.lea (100:.Nat, <100:.Nat; i32>, 0) (alloc_val, 1:(.Idx 100));
    .let store = %mem.store (i32, 0) (alloc_mem, lea, argc);

    .let f_diff = %autodiff.ad (.Cn [[%mem.M, %mem.Ptr («100:.Nat; i32», 0)],.Cn[%mem.M, i32]]) f;

    f_diff ((store, alloc_val),ret_cont)
};


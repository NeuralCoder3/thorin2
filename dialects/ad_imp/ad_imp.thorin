/// # The automatic differentiation dialect {#autodiff}
///
/// [TOC]
///
/// ## Dependencies
///
.import mem;
.import compile;
/// For derivatives:
.import core;
.import direct;
///
///
/// ## Types
///
.ax %ad_imp.tangent_type: * -> *, normalize_tangent_type;
///
/// ## Operations
///
/// ### %autodiff.ad
/// 
/// This axiom operates on functions and types.
///
/// For function types the augmented type is computed: `(T -> U) => (T -> U × (U -> T))`
.ax %ad_imp.autodiff_type: Π * -> *, normalize_autodiff_type;

/// On closed terms (functions, operators, ho arguments, registered axioms, etc.) the augmented term is returned.
/// The augmented term `f'` returns the result together with the pullback.
/// `autodiff f = f' = λ args. (f args, f*)` 
.ax %ad_imp.ad: Π [T: *] -> T -> 
    %ad_imp.autodiff_type (T);
.ax %ad_imp.autodiff: Π [T: *] -> T -> 
    %ad_imp.autodiff_type (T), normalize_autodiff;
///
/// ## Compilation Passes and Phases
/// 
/// ### Passes
/// 
.ax %ad_imp.ad_reduce_pass: %compile.Pass;
.ax %ad_imp.ad_eval_pass: %compile.Pass;
// .ax %ad_imp.ad_zero_pass: %compile.Pass;
// .ax %ad_imp.ad_zero_cleanup_pass: %compile.Pass;
// .ax %ad_imp.ad_ext_cleanup_pass: %compile.Pass;
/// 
/// ### Phases
/// 
.let ad_cleanup_phase = {
    %compile.phases_to_phase (⊤:.Nat)
        (
            // (%compile.passes_to_phase 1 %ad_imp.ad_zero_cleanup_pass),
            // (%compile.passes_to_phase 1 %ad_imp.ad_ext_cleanup_pass)
        )
};
.let ad_phase = {
    %compile.phases_to_phase (⊤:.Nat)
        (
            optimization_phase,
            (%compile.passes_to_phase 1 %ad_imp.ad_reduce_pass),
            (%compile.passes_to_phase 1 %ad_imp.ad_eval_pass),
            // (%compile.passes_to_phase 1 %ad_imp.ad_zero_pass),
            // ad_cleanup_phase
        )
};

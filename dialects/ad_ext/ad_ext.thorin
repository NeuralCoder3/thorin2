/// # The autodiff extension dialect {#ad_ext}
///
/// [TOC]
///
/// A collection of automatic differentiated versions of axioms.
///
/// ## Dependencies
///
.import core;
///
/// ## Types
///
/// none 
///
/// ## Operations
///
/// none 
///
/// ## Registered translations
/// 
/// In this section, we define translations for axioms of other dialects.
/// This best would be done using a register mechanism in a third dialect or at least in a separate file.
/// 
/// The general concept is that a call to an axiom is replaced with a call to the augmented axiom.
/// The augmented axiom needs a wrapper for meta arguments (HO-function).
/// Appropiate cps2ds wrappers are introduced to handle that the augmented axioms are in cps where the original axioms were in ds.
/// Example:
/// ```
/// mul' => args -> result*pullback
/// call: r    = mul  (m,w) (a,b) 
/// res : r,r* = mul' (m,w) (a,b)
/// ```
/// The types (with `Int` for `(Int w)`) are:
/// ```
/// mul : Π [m:.Nat,w:.Nat] -> [a:Int,b:Int] -> Int
/// r   : Int
/// r*  : cn[Int,cn[Int,Int]]
/// ```
/// The pullback has to be in cps for compliance.
/// ```
/// mul* := λ s. (s*b,s*a)
/// mul'_cps : Π [m:.Nat,w:.Nat] -> cn[[Int,Int],cn[Int,   cn[Int,cn[Int,Int]]]]
/// r,r* = (cps2ds (mul'_cps (m,w))) (a,b)
/// ```
/// 
/// The pullback is the derivative with respect to the input (weighted with the out tangent).
/// For arithmetic operations, s is simply multiplied to each input tangent:
/// `∂_i f(x1,...,xn) * s`
/// You will also come to the conclusion that the applied partial pullback needs to be:
/// `sum x_i*(∂_i f(x1,...,xn) * s) = sum x_i*(•)` with • as the formula from above
/// This is a direct result from the chain composition with the partial pullback of a tuple.
/// The tuple pullback transports the partial pullbacks of the operands and handles the sums.
/// By its nature the pullback of a tuple needs to be a sum.
/// 
/// ### %core.icmp.xYgLE (sle)
/// 
/// The comparison pullback exists formally but is not used.
/// 
.lam .extern internal_diff_core_icmp_xYgLE 
    ![w: .Nat] ->
    (.Cn[[.Idx w, .Idx w], .Cn[.Idx 2, .Cn[.Idx 2, .Cn[.Idx w, .Idx w]]]])
    = { 
        .cn inner_cmp 
        ![[a: .Idx w, b: .Idx w], ret:.Cn[.Idx 2, .Cn[.Idx 2, .Cn[.Idx w, .Idx w]]]]
        = { 
            .let result = %core.icmp.sle (w) (a,b);
            .cn cmp_pb ![s: .Idx 2, pb_ret:.Cn[.Idx w, .Idx w]]
            = { 
                .let z = 0:(.Idx w);
                pb_ret (z, z)
            };
            ret (result,cmp_pb)
        };
        inner_cmp
    };
/// core.icmp.e
.lam .extern internal_diff_core_icmp_xyglE 
    ![w: .Nat] ->
    (.Cn[[.Idx w, .Idx w], .Cn[.Idx 2, .Cn[.Idx 2, .Cn[.Idx w, .Idx w]]]])
    = { 
        .cn inner_cmp 
        ![[a: .Idx w, b: .Idx w], ret:.Cn[.Idx 2, .Cn[.Idx 2, .Cn[.Idx w, .Idx w]]]]
        = { 
            .let result = %core.icmp.e (w) (a,b);
            .cn cmp_pb ![s: .Idx 2, pb_ret:.Cn[.Idx w, .Idx w]]
            = { 
                .let z = 0:(.Idx w);
                pb_ret (z, z)
            };
            ret (result,cmp_pb)
        };
        inner_cmp
    };
///
/// ### %core.wrap.add
/// 
/// s ↦ (s, s)
///
.lam .extern internal_diff_core_wrap_add
    ![m:.Nat, w:.Nat] -> 
    (.Cn[[.Idx w, .Idx w], .Cn[.Idx w, .Cn[.Idx w, .Cn[.Idx w, .Idx w]]]])
    = { 
    .cn inner_add_deriv_cps
        ![[a:.Idx w, b:.Idx w], ret:.Cn[.Idx w, .Cn[.Idx w, .Cn[.Idx w, .Idx w]]]]
        = { 
        .let result = %core.wrap.add (m,w) (a,b);
        .cn add_pb ![s:(.Idx w), pb_ret:(.Cn [.Idx w, .Idx w])] = { 
            pb_ret (s,s)
        };
        ret (result,add_pb)
    };
    inner_add_deriv_cps
};
///
/// ### %core.wrap.mul
///
/// s ↦ (s*b, s*a)
/// 
.lam .extern internal_diff_core_wrap_mul
    ![m:.Nat, w:.Nat] -> 
    (.Cn[[.Idx w, .Idx w], .Cn[.Idx w, .Cn[.Idx w, .Cn[.Idx w, .Idx w]]]])
    = { 
    .cn inner_mul_deriv_cps
        ![[a:.Idx w, b:.Idx w], ret:.Cn[.Idx w, .Cn[.Idx w, .Cn[.Idx w, .Idx w]]]]@(.tt)
        = { 
        .let result = %core.wrap.mul (m,w) (a,b);
        .cn mul_pb ![s:(.Idx w), pb_ret:(.Cn [.Idx w, .Idx w])]@(.tt) = { 
            .let lhs = %core.wrap.mul (m,w) (s,b);
            .let rhs = %core.wrap.mul (m,w) (s,a);
            pb_ret (lhs, rhs)
        };
        ret (result,mul_pb)
    };
    inner_mul_deriv_cps
};

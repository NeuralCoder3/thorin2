/// # The automatic differentiation dialect {#autodiff}
///
/// [TOC]
///
/// ## Dependencies
///
.import mem;
/// For derivatives:
.import core;
///
///
/// ## Types
///
.ax %autodiff.tangent_type: * -> *, normalize_tangent_type;
///
/// ## Operations
///
/// ### %autodiff.autodiff
/// 
/// This axiom operates on functions and types.
///
/// For function types the augmented type is computed: `(T -> U) => (T -> U × (U -> T))`
.ax %autodiff.autodiff_type: * -> *, 
    normalize_autodiff_type;
/// On closed terms (functions, operators, ho arguments, registered axioms, etc.) the augmented term is returned.
/// The augmented term `f'` returns the result together with the pullback.
/// `autodiff f = f' = λ args. (f args, f*)` 
.ax %autodiff.autodiff: Π [T: *] -> T -> 
    %autodiff.autodiff_type T, 
    normalize_autodiff;
///
/// ### %autodiff.zero
/// 
/// Represents universal zero such that `(zero T) +_T t = t`.
///
.ax %autodiff.zero: Π [T:*] -> T, normalize_zero;
///
/// ### %autodiff.add
/// 
/// A universal addition that consumes zeros and defaults to normal addition for scalar types.
/// It lifts additions over types with structure and performs special casing for types with do not allow for addition.
/// The sum construct performs addition over a list of terms.
///
/// TODO: how do we handle summations that need memory? (grab current memory?)
.ax %autodiff.add: Π [T:*] -> [T,T] -> T, normalize_add;
.ax %autodiff.sum: Π [n:.Nat,T:*] -> «n; T» -> T, normalize_sum;
